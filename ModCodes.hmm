Code "ModMain" by "Icedude_907" does
/*
Adds an additional method of activating Cross Slash.
Costs Quick Cyloop Energy.
*/
//
#lib "Player"
#lib "BlackboardBattle"
#import "Blackboard"
#include "BlackboardStatus" noemit
#load "System.Numerics.dll"

using System.Numerics;
using System.Runtime.InteropServices;

static float CrossSlashEnergyCost = 60.0f;
static bool IsKnockedInRecoverySmash = false;

[StructLayout(LayoutKind.Explicit, Size = 0x100)]
public struct BattleData{
    /// An instance of `app::player::BlackboardContent`, the base class for `app::player::BlackboardBattle`.
    [FieldOffset(0)]    public BlackboardContent BlackboardContent;
    /// The number of attack combos performed by the player.
    [FieldOffset(0xA8)] public int ComboCount;
    /// The value of the Phantom Rush gauge.
    [FieldOffset(0xAC)] public float PhantomRushAmount;
    /// The value of the Quick Cyloop gauge.
    [FieldOffset(0xB8)] public float QuickCyloopAmount;

    /// <summary>
    /// Contains various flags
    /// bit 6 - Is Phantom Rush Active
    /// </summary>
    [FieldOffset(0xF0)] public byte flags1;
    // I found this value by tracing the QuickCyloopAmount in Cheat Engine and then monitoring the adjacent memory till I found a flag that triggered when emptying gague.
    /// Is the Quick Cyloop gauge active (false) or recharging (true)
    [FieldOffset(0xF1)] public bool QuickCyloopRecharging;

}
//
{
    if (Player.GetPlayerType() != Player.PlayerType.Sonic){
        return;
    }

    var PlayerState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var pBlackboardBattle = (BattleData*)BlackboardBattle.Get();

    // TODO: Explore potential move properties in the binary rather than amending.

    // Logic for enhanced Cross Slash
    if( // Note this bypasses move unlock requirements, cancels out of moves, is usable anywhere (cutscenes, cyberspace) and generally does wacky things. Also, with no target you orbit around world origin.
        !Player.Status.IsGroundedSpecial()  // Must be airbourne
        && PlayerState != Sonic.StateID.StateCrossSlash // Prevent multiple activation
        && PlayerState != Sonic.StateID.StateSpinBoost  // Prevent accidental activation
        && (IS_WORLD_FLAG(IsBattle) || PlayerState == Sonic.StateID.StateSonicBoomKick) // Prevent accidental activation
        && Player.Input.IsDown(Player.InputActionType.PlayerSonicboom) && Player.Input.IsDown(Player.InputActionType.PlayerCyloop) // Keybind
        && pBlackboardBattle != null // I have no idea how people discovered this but its really amazing how deep people traversed the tree.
    ){
        var qcamount = pBlackboardBattle->QuickCyloopAmount;
        if(!pBlackboardBattle->QuickCyloopRecharging && qcamount > 0.0){
            qcamount -= CrossSlashEnergyCost;
            if(qcamount < 0.0){
                qcamount = 0.0f;
                pBlackboardBattle->QuickCyloopRecharging = true;
            }
            pBlackboardBattle->QuickCyloopAmount = qcamount;
            // TODO: How do I check to see if Sonic has a target?
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateCrossSlash);
        }
    }

    // Logic for Homing Shot Cancels
    if(PlayerState == Sonic.StateID.StateHomingShot){
        // TODO: Parry canceliing
        // Dodge cancelling (by default this sends backwards which is a fair trade off)
        if( Player.Input.IsPressed(Player.InputActionType.PlayerLeftStep) ||
            Player.Input.IsPressed(Player.InputActionType.PlayerRightStep)
        ){
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateAvoid);
        }
        // Stomp cancelling
        if( Player.Input.IsPressed(Player.InputActionType.PlayerStomping)){
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateStompingDown);
        }
    }

    // Logic for Recovery Smash
    // TODO: Hook into the game's flag to set it off if we aren't rushing.
    if(PlayerState == Sonic.StateID.StateDamageBlowOff || PlayerState == Sonic.StateID.StateDamageBlowOffHeavy){
        IsKnockedInRecoverySmash = true;
    }if(PlayerState == Sonic.StateID.StateSmash){ // Grand Slam is just called Smash by the game and they use identical states.
        if(pBlackboardBattle != null){
            // Console.WriteLine($"Allowed: {((pBlackboardBattle->flags1 & 0b0100_0000) != 0)}");
            pBlackboardBattle->PhantomRushAmount = 0;
        }
    }else{
        IsKnockedInRecoverySmash = false;
    }
}

Code "Forensics" by "Icedude_907" does "research"
//
    #lib "BlackboardItem"
    #lib "BlackboardBattle"
    #lib "MathHelpers"
    #lib "PhotoMode"
    #lib "Player"
    #lib "XInput"

    using System.Diagnostics;
    using System.Runtime.InteropServices;

    static bool IsKeyDown(Keys in_keys){
        return (GetAsyncKeyState(in_keys) & 0x8000) != 0;
    }
    [DllImport("user32.dll")]
    static extern IntPtr GetForegroundWindow();
//
{
    if (GetForegroundWindow() != Process.GetCurrentProcess().MainWindowHandle)
        return;

    if(IsKeyDown(Keys.L)){
        var pBlackboardBattle = BlackboardBattle.Get();
        var pBlackboardItem = BlackboardItem.Get();
        var PlayerState = Player.State.GetCurrentStateID<Sonic.StateID>();
        // I watch the memory here using cheatengine or x64dbg
        // Console.WriteLine($"Debug: battle 0x{(ulong)pBlackboardBattle:X}, item 0x{(ulong)pBlackboardItem:X}: ");
        Console.WriteLine($"PlayerState: {PlayerState.ToString()}")
    }
}