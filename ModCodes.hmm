Code "ModMain" by "Icedude_907" does
/*
Adds an additional method of activating Cross Slash.
Costs Quick Cyloop Energy.
*/
//
#lib "Player"
#lib "BlackboardBattle"
#import "Blackboard"
#include "BlackboardStatus" noemit
#load "System.Numerics.dll"

using System.Numerics;
using System.Runtime.InteropServices;

static float CrossSlashEnergyCost = 60.0f; // Additional on top of player_common quickCyloop cost (I've set to 0 to allow the button to be used always.)
static float QuickCyloopEnergyCost = 40.0f;
static bool IsCrossSlashing = false;
static bool IsQuickCylooping = false;
static bool IsKnockedBack = false;

// TODO: Merge into HMMCodes
[StructLayout(LayoutKind.Explicit, Size = 0x100)]
public struct BattleData{
    /// An instance of `app::player::BlackboardContent`, the base class for `app::player::BlackboardBattle`.
    [FieldOffset(0)]    public BlackboardContent BlackboardContent;
    /// The number of attack combos performed by the player.
    [FieldOffset(0xA8)] public int ComboCount;
    /// The value of the Phantom Rush gauge.
    [FieldOffset(0xAC)] public float PhantomRushAmount;
    /// The value of the Quick Cyloop gauge.
    [FieldOffset(0xB8)] public float QuickCyloopAmount;

    /// <summary>
    /// Contains various flags
    /// bit 6 - Is Phantom Rush Active
    /// </summary>
    [FieldOffset(0xF0)] public byte flags1;
    // I found this value by tracing the QuickCyloopAmount in Cheat Engine and then monitoring the adjacent memory till I found a flag that triggered when emptying gague.
    /// Is the Quick Cyloop gauge active (false) or recharging (true)
    [FieldOffset(0xF1)] public bool QuickCyloopRecharging;

}
//
{
    // Remove energy and recharge if emptied out.
    bool deductQuickCyloopEnergy(BattleData* pBlackboardBattle, float amount){
        var newAmount = pBlackboardBattle->QuickCyloopAmount - amount;
        if(newAmount < 0.0){
            newAmount = 0.0f;
            pBlackboardBattle->QuickCyloopRecharging = true;
        }
        pBlackboardBattle->QuickCyloopAmount = newAmount;

        return true;
    }

    // ---------
    // Main code.
    // -----------

    if (Player.GetPlayerType() != Player.PlayerType.Sonic){
        return;
    }

    var PlayerState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var pBlackboardBattle = (BattleData*)BlackboardBattle.Get();

    // TODO: Explore potential move properties in the binary rather than amending.
    // TODO: Figure out how to create move targets, edit lock on range, and check lock on range.

    // Logic for enhanced Cross Slash
    // Input is TransitAir(Targeted) from SonicBoom with the Cyloop button - see player_common.rfl
    if(pBlackboardBattle != null // I have no idea how people discovered this but its really amazing how deep people traversed the tree.
    && PlayerState == Sonic.StateID.StateCrossSlash
    ){
        if(pBlackboardBattle->QuickCyloopRecharging){ // Cancel the move
            Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
        }else if(!IsCrossSlashing){ // Deduct QuickCyloop Energy when inputting the move only on the first frame.
            IsCrossSlashing = true;
            deductQuickCyloopEnergy(pBlackboardBattle, CrossSlashEnergyCost);
        }
    }else{
        var wasCrossSlashing = IsCrossSlashing;
        IsCrossSlashing = false;
        // Post move auto transition into sonic boom (can't be done in player_common unless you repress the button - which causes an offset teleport (statecombowarp).)
        if(wasCrossSlashing && Player.Input.IsDown(Player.InputActionType.PlayerSonicboom)){
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
        }
        // TODO: Post move buffer transition into self.
    }

    // Logic for Quick Cyloop
    // Due to a bug in the game, an Energy level below QuickCyloopEnergyCost cannot ever activate moves.
    // In normal gameplay since QuickCyloop always uses 50% this never triggers, but now we have CrossSlash using different energy amounts so this can be triggered.
    // Therefore we set the internal energy cost to 0, and deduct energy externally here.
    if(pBlackboardBattle != null && PlayerState == Sonic.StateID.StateQuickCyloop){
        if(!IsQuickCylooping){
            deductQuickCyloopEnergy(pBlackboardBattle, QuickCyloopEnergyCost);
        }
        IsQuickCylooping = true;
    }else{
        IsQuickCylooping = false;
    }

    // Logic for Homing Shot Cancels
    if(PlayerState == Sonic.StateID.StateHomingShot){
        // TODO: Parry canceliing
        // Dodge cancelling (by default this sends backwards which is a fair trade off)
        if( Player.Input.IsPressed(Player.InputActionType.PlayerLeftStep) ||
            Player.Input.IsPressed(Player.InputActionType.PlayerRightStep)
        ){
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateAvoid);
        }
        // Stomp cancelling
        if(Player.Input.IsPressed(Player.InputActionType.PlayerStomping)){
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateStompingDown);
        }
    }

    // Logic for Recovery Smash
    // TODO: Hook into the game's flag to set it off if we aren't rushing.
    if(PlayerState == Sonic.StateID.StateDamageBlowOff || PlayerState == Sonic.StateID.StateDamageBlowOffHeavy){
        IsKnockedBack = true;
    }if(PlayerState == Sonic.StateID.StateSmash){ // Grand Slam is just called Smash by the game and they use identical states.
        if(pBlackboardBattle != null){
            var isPhantomRushActive = ((pBlackboardBattle->flags1 & 0b0100_0000) != 0);
            // Console.WriteLine($"Allowed: {isPhantomRushActive}");
            pBlackboardBattle->PhantomRushAmount = 0;
        }
    }else{
        IsKnockedBack = false;
    }

    // TODO: Persuit Kick
    // Cyclone Kick / Charge Attack should only use persuit as a follow up if the final hit connects
    // Persuit should be on the unlock tree.
    // TODO: Disable cyclone kick until touching the ground after doing once (currently you can cyclone, homing, cyclone, loop)


    // TODO: Rail Crouch
    // TODO: Modify rail boost to consume a chunk on activation, set to a minimum speed, and increase the speed limit as time goes on
    // TODO: Make air boost consume a chunk when pressed and a bit while held.
    // TODO: Make ground boost consume a lesser chunk when pressed
    // TODO: Decrease koko boost expansion rewards
    // TODO: Decrease fishing koko amounts
    // TODO: Decrease upgrade koko amounts
    // TODO: Decrease max levels
}

Code "Forensics" by "Icedude_907" does "research"
//
    #lib "BlackboardItem"
    #lib "BlackboardBattle"
    #lib "MathHelpers"
    #lib "PhotoMode"
    #lib "Player"
    #lib "XInput"

    using System.Diagnostics;
    using System.Runtime.InteropServices;

    static bool IsKeyDown(Keys in_keys){
        return (GetAsyncKeyState(in_keys) & 0x8000) != 0;
    }
    [DllImport("user32.dll")]
    static extern IntPtr GetForegroundWindow();
//
{
    if (GetForegroundWindow() != Process.GetCurrentProcess().MainWindowHandle)
        return;

    if(IsKeyDown(Keys.L)){
        var pBlackboardBattle = BlackboardBattle.Get();
        var pBlackboardItem = BlackboardItem.Get();
        var PlayerState = Player.State.GetCurrentStateID<Sonic.StateID>();
        // I watch the memory here using cheatengine or x64dbg
        // Console.WriteLine($"Debug: battle 0x{(ulong)pBlackboardBattle:X}, item 0x{(ulong)pBlackboardItem:X}: ");
        Console.WriteLine($"PlayerState: {PlayerState.ToString()}")
    }
}